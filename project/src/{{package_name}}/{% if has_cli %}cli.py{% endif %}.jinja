import logging
import os
from typing import Optional

import typer
from colorama import Fore, Style
from dotenv import load_dotenv
from pydantic_settings import BaseSettings, SettingsConfigDict

from . import __author__, __email__, __version__
from .Calculator import Calculator

logger = logging.getLogger(__name__)

# Ensure `.env.secret` takes precedence over `.env`
dotenv_path = os.path.join(os.getcwd(), ".env")
load_dotenv(dotenv_path=dotenv_path, override=False)

dotenv_secret_path = os.path.join(os.getcwd(), ".env.secret")
load_dotenv(dotenv_path=dotenv_secret_path, override=True)


class AppConfig(BaseSettings):
    """Configuration settings for the application."""

    log_level: int

    model_config = SettingsConfigDict(env_file_encoding="utf-8")


app = typer.Typer(
    epilog=__doc__,
    help=", ".join(
        [
            f"{__package__}",
            f"version {__version__}",
            f"by {__author__} <{__email__}>",
        ],
    ),
    name="{{ project_slug }}",
)


def setup_logging(
    log_level: Optional[int | str] = None, verbosity: Optional[int] = None
) -> int:
    """
    Configure logging based on provided log level or verbosity.

    log_level: Specific log level (int or str).
    verbosity: Verbosity level to determine log level.

    Returns:
    -------
        int: Effective log level.
    """
    if verbosity is not None:
        # Adjust log level based on verbosity
        if verbosity == 0:
            level = logging.ERROR
        elif verbosity == 1:
            level = logging.WARNING
        elif verbosity == 2:
            level = logging.INFO
        else:  # verbosity >= 3
            level = logging.DEBUG
    elif log_level is not None:
        if isinstance(log_level, str):
            level = getattr(logging, log_level.upper())
        else:
            level = log_level
    else:
        level = logging.WARNING

    # Create a colorful formatter
    format_str = (
        f"{Style.BRIGHT}{Fore.CYAN}%(asctime)s{Style.RESET_ALL}"
        f" {Style.BRIGHT}{Fore.MAGENTA}%(levelname)s{Style.RESET_ALL}"
        f" %(message)s"
    )
    logging.basicConfig(level=level, force=True, format=format_str)

    return logging.getLogger().getEffectiveLevel()


@app.callback()
def main(
    ctx: typer.Context,
    log_level: str = typer.Option(
        None,
        "--log-level",
        help="Set the specific log level (e.g., 10 or DEBUG, 20 or INFO, etc.).",
        envvar="LOG_LEVEL",
    ),
    verbosity: int = typer.Option(
        0,
        "--verbosity",
        "-v",
        count=True,
        help="Increase verbosity if no log-level is defined.",
    ),
):
    """
    Main entry point for the CLI, handling global options.
    """

    ctx.obj = AppConfig(log_level=setup_logging(log_level, verbosity))


@app.command("add")
def add(
    ctx: typer.Context,
    a: int = typer.Argument(..., help="The first number."),
    b: int = typer.Argument(..., help="The second number."),
) -> int:
    """Main entry point for {{ project_slug }}.

    This method sets up the argument parser and initializes the main class.

    Returns:
        int: The exit code.
    """
    config = ctx.obj
    logger.info(f"Starting bot with log_level={config.log_level}")

    calculator = Calculator(a, b)
    result = calculator.add()
    print(f"The result is: {result}")

    return 0


if __name__ == "__main__":
    app()
